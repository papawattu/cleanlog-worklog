
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/papawattu/cleanlog-worklog/client/main.go (0.0%)</option>
				
				<option value="file1">github.com/papawattu/cleanlog-worklog/cmd/main.go (0.0%)</option>
				
				<option value="file2">github.com/papawattu/cleanlog-worklog/internal/controllers/workcontroller.go (57.3%)</option>
				
				<option value="file3">github.com/papawattu/cleanlog-worklog/internal/events/eventbroadcaster.go (0.0%)</option>
				
				<option value="file4">github.com/papawattu/cleanlog-worklog/internal/events/eventstream.go (0.0%)</option>
				
				<option value="file5">github.com/papawattu/cleanlog-worklog/internal/models/work.go (100.0%)</option>
				
				<option value="file6">github.com/papawattu/cleanlog-worklog/internal/repo/inmemoryrepo.go (56.5%)</option>
				
				<option value="file7">github.com/papawattu/cleanlog-worklog/internal/services/worksvc.go (25.9%)</option>
				
				<option value="file8">github.com/papawattu/cleanlog-worklog/internal/utils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/papawattu/cleanlog-worklog/types"
)

func CreateWorkLog(description string, baseUri string) (string, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/worklog", baseUri)
        body := types.CreateWorkRequest{Description: description, Date: "2024-01-01"}
        b, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error marshalling JSON:", err)
                return "", err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(b))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error creating request:", err)
                return "", err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Authorization: Basic amFtaWU6c2ltcHNvbnM=")
        resp, err := http.DefaultClient.Do(req)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error:", err)
        }</span>
        <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                defer resp.Body.Close()
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                log.Fatalf("Error: status code %d\n", resp.StatusCode)
                return "", nil
        }</span>

        <span class="cov0" title="0">log.Printf("Work log created with ID: %s\n", resp.Header.Get("Location"))

        return resp.Header.Get("Location"), nil</span>
}
func GetWorkLog(loc string, baseUri string) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s%s", baseUri, loc)

        var resp *http.Response
        var err error
        var count int = 0

        for </span><span class="cov0" title="0">{
                resp, err = http.Get(url)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Error:", err)
                        return
                }</span>

                <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        if count &gt; 5 </span><span class="cov0" title="0">{
                                log.Fatalln("Work log not found")
                                return
                        }</span>
                        <span class="cov0" title="0">count++
                        log.Printf("Work log not found at %s waiting - times %d\n", url, count)
                        time.Sleep(1 * time.Second)</span>
                } else<span class="cov0" title="0"> {
                        if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                                log.Printf("Work log found at %s\n", url)
                                break</span>
                        } else<span class="cov0" title="0"> {
                                log.Fatalf("Error: status code %d\n", resp.StatusCode)
                                return
                        }</span>
                }
        }
        <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{

                defer resp.Body.Close()
        }</span>

        <span class="cov0" title="0">log.Printf("Body: %v\n", resp.Body)
        r := &amp;types.WorkResponse{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;r); err != nil </span><span class="cov0" title="0">{
                log.Println("Error decoding JSON:", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Work log: %v", r)</span>

}

func GetAllWorkLogs(baseUri string) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/worklog/", baseUri)
        req, err := http.NewRequest(http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error:", err)
                return
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Authorization: Basic amFtaWU6c2ltcHNvbnM=")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error:", err)
                return
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                log.Println("Error: status code", resp.StatusCode)
                return
        }</span>

        <span class="cov0" title="0">r := types.ListWorkResponse{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;r); err != nil </span><span class="cov0" title="0">{
                log.Println("Error decoding JSON:", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Work logs: %+v", r)</span>
}

func DeleteWorkLog(loc string, baseUri string) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s%s", baseUri, loc)

        req, err := http.NewRequest(http.MethodDelete, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("Error:", err)
                return
        }</span>

        <span class="cov0" title="0">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("Error:", err)
                return
        }</span>

        <span class="cov0" title="0">log.Println("Response status code:", resp.StatusCode)
        if resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                log.Fatalln("Error: status code ", resp.StatusCode)
                return
        }</span>

        <span class="cov0" title="0">log.Println("Work log deleted")</span>
}
func main() <span class="cov0" title="0">{
        var baseUri string
        flag.StringVar(&amp;baseUri, "baseUri", "http://localhost:3000", "Base URI for the worklog service")
        flag.Parse()

        log.Println("Creating work log")
        id, err := CreateWorkLog("Work log 1", baseUri)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating work log: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Getting work log %s\n", id)
        GetWorkLog(id, baseUri)

        log.Println("Getting all work logs")
        GetAllWorkLogs(baseUri)

        log.Printf("Deleting work log %s\n", id)
        DeleteWorkLog(id, baseUri)</span>

        // ctx, cancel := context.WithTimeout(context.Background(), 90*time.Second)

        // defer cancel()

        // ch := make(chan string)

        // topic := "worklog"
        // go events.EventStream(ctx, "http://localhost:8090", ch, topic)

        // for {
        //         select {
        //         case &lt;-ctx.Done():
        //                 log.Println("Timeout")
        //                 return
        //         case e := &lt;-ch:
        //                 log.Println(e)
        //         default:
        //                 //

        //         }
        // }

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"

        "github.com/papawattu/cleanlog-worklog/internal/controllers"
        "github.com/papawattu/cleanlog-worklog/internal/events"
        "github.com/papawattu/cleanlog-worklog/internal/repo"
        "github.com/papawattu/cleanlog-worklog/internal/services"
)

func startWebServer(server *http.Server, ws services.WorkService) error <span class="cov0" title="0">{

        // make a middleware array

        // middleware := []func(http.Handler) http.Handler{
        //         func(next http.Handler) http.Handler {
        //                 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        //                         log.Printf("Request received: %s %s\n", r.Method, r.URL)
        //                         next.ServeHTTP(w, r)
        //                         log.Printf("Request completed: %s %s\n", r.Method, r.URL)
        //                 })
        //         },
        // }

        middleware := []func(http.Handler) http.Handler{
                func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                log.Printf("Request received: %s %s\n", r.Method, r.URL)
                                next.ServeHTTP(w, r)
                                log.Printf("Request completed: %s %s\n", r.Method, r.URL)
                        }</span>)
                },
        }
        <span class="cov0" title="0">controllers.NewWorkController(context.Background(), server.Handler.(*http.ServeMux), ws, middleware)

        log.Printf("Starting Work Log server on port %s\n", server.Addr)

        return server.ListenAndServe()</span>

}
func main() <span class="cov0" title="0">{

        ctx := context.Background()

        var (
                workService services.WorkService
                port        string
                server      *http.Server
        )

        port = "3000"

        if os.Getenv("PORT") != "" </span><span class="cov0" title="0">{
                port = os.Getenv("PORT")
        }</span>

        <span class="cov0" title="0">topic := "worklog"

        if os.Getenv("EVENT_TOPIC") != "" </span><span class="cov0" title="0">{
                topic = os.Getenv("EVENT_TOPIC")
        }</span>

        <span class="cov0" title="0">if os.Getenv("EVENT_BROADCASTER") != "" &amp;&amp; os.Getenv("EVENT_STREAM") != "" </span><span class="cov0" title="0">{
                eventBroadcaster := events.NewEventBroadcaster(ctx, repo.NewWorkLogRepository(), os.Getenv("EVENT_BROADCASTER"), os.Getenv("EVENT_STREAM"), topic)
                workService = services.NewWorkService(eventBroadcaster)
        }</span> else<span class="cov0" title="0"> {
                workService = services.NewWorkService(repo.NewWorkLogRepository())
        }</span>

        <span class="cov0" title="0">server = &amp;http.Server{
                Addr:    fmt.Sprintf(":%s", port),
                Handler: http.NewServeMux(),
        }

        if err := startWebServer(server, workService); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "strconv"
        "time"

        "github.com/papawattu/cleanlog-worklog/internal/models"
        "github.com/papawattu/cleanlog-worklog/internal/services"
        "github.com/papawattu/cleanlog-worklog/types"
)

type ControllerPaths map[string]func(wc *WorkController, ctx context.Context) func(http.ResponseWriter, *http.Request)

func (cp ControllerPaths) GetPaths() map[string]func(wc *WorkController, ctx context.Context) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return cp
}</span>

type WorkController struct {
        workService services.WorkService
        server      *http.ServeMux
        controllers ControllerPaths
}

func inlineTasks(tasks []models.Task) []int <span class="cov8" title="1">{
        if tasks == nil </span><span class="cov8" title="1">{
                return make([]int, 0)
        }</span>
        <span class="cov8" title="1">t := make([]int, 0)
        for _, task := range tasks </span><span class="cov8" title="1">{
                t = append(t, task.TaskID)
        }</span>
        <span class="cov8" title="1">return t</span>
}
func (wc *WorkController) PostRequest(ctx context.Context) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                log.Println("Creating work log")
                var t types.CreateWorkRequest

                json.NewDecoder(r.Body).Decode(&amp;t)

                startDate, err := time.Parse("2006-01-02", t.Date)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid date format", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">workID, err := wc.workService.CreateWorkLog(ctx, t.Description, startDate)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error starting work: %v", err)
                }</span>

                <span class="cov8" title="1">w.Header().Set("Location", "/api/worklog/"+strconv.Itoa(workID))
                w.WriteHeader(http.StatusCreated)</span>
        }

}

func (wc *WorkController) GetRequestById(ctx context.Context) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                workId := r.PathValue("workid")
                if workId == "" </span><span class="cov0" title="0">{
                        http.Error(w, "workId is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">id, err := strconv.Atoi(workId)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "workId must be an integer", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">log.Printf("Getting work log by id %d", id)

                work, err := wc.workService.GetWorkLog(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error getting work", http.StatusNotFound)
                        return
                }</span>

                <span class="cov8" title="1">if work == nil </span><span class="cov0" title="0">{
                        http.Error(w, "Work log not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov8" title="1">log.Printf("Work log: %v", work)
                wlr := types.WorkResponse{
                        WorkID:      *work.WorkLogID,
                        Description: work.WorkLogDescription,
                        TaskIds:     inlineTasks(work.Tasks),
                        Date:        work.WorkLogDate.Format("2006-01-02"),
                        CreatedAt:   work.CreationDate.Format(time.RFC3339Nano),
                        UpdatedAt:   work.LastUpdateDate.Format(time.RFC3339Nano),
                        UserID:      work.UserID,
                }
                json.NewEncoder(w).Encode(wlr)</span>
        }
}

func (wc *WorkController) GetRequestAll(ctx context.Context) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                log.Println("Getting all work logs")
                // auth := r.Header.Get("Authorization")

                // if auth == "" {
                //         http.Error(w, "Authorization header is required", http.StatusBadRequest)
                //         return
                // }

                // stringSplit := strings.Split(auth, " ")
                // if len(stringSplit) != 2 {
                //         http.Error(w, "Authorization header must be in the format Basic &lt;token&gt;", http.StatusBadRequest)
                //         return
                // }

                // token := stringSplit[1]

                // base64Token, err := base64.StdEncoding.DecodeString(token)
                // if err != nil {
                //         http.Error(w, "Error decoding token", http.StatusBadRequest)
                //         return
                // }

                // tokenSplit := strings.Split(string(base64Token), ":")

                // if len(tokenSplit) != 2 {
                //         http.Error(w, "Token must be in the format &lt;userId&gt;:&lt;password&gt;", http.StatusBadRequest)
                //         return
                // }

                // userId := tokenSplit[0]

                // if userId == "" {
                //         http.Error(w, "userId is required", http.StatusBadRequest)
                //         return
                // }

                // TODO: Implement user id

                workLogs, err := wc.workService.GetAllWorkLog(ctx, 0)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error getting work logs", http.StatusNotFound)
                        return
                }</span>

                <span class="cov8" title="1">wlr := &amp;types.ListWorkResponse{}

                wlr.WorkResponses = make([]types.WorkResponse, 0)

                for _, workLog := range workLogs </span><span class="cov0" title="0">{
                        wlr.WorkResponses = append(wlr.WorkResponses,
                                types.WorkResponse{
                                        WorkID:      *workLog.WorkLogID,
                                        Description: workLog.WorkLogDescription,
                                        TaskIds:     inlineTasks(workLog.Tasks),
                                        Date:        workLog.WorkLogDate.Format("2006-01-02"),
                                        CreatedAt:   workLog.CreationDate.Format("2006-01-02"),
                                        UpdatedAt:   workLog.LastUpdateDate.Format("2006-01-02"),
                                })
                }</span>
                <span class="cov8" title="1">json.NewEncoder(w).Encode(wlr)</span>
        }
}

func (wc *WorkController) DeleteRequest(ctx context.Context) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                workId := r.PathValue("workid")
                if workId == "" </span><span class="cov0" title="0">{
                        http.Error(w, "workId is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">id, err := strconv.Atoi(workId)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "workId must be an integer", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">log.Printf("Deleting work log by id %d", id)

                err = wc.workService.DeleteWorkLog(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error deleting work", http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
        }
}
func NewWorkController(ctx context.Context, server *http.ServeMux,
        workService services.WorkService,
        middleware []func(http.Handler) http.Handler) *WorkController <span class="cov8" title="1">{

        wc := &amp;WorkController{
                workService: workService,
                controllers: ControllerPaths{
                        "POST /api/worklog":            (*WorkController).PostRequest,
                        "GET /api/worklog/{workid}":    (*WorkController).GetRequestById,
                        "GET /api/worklog/":            (*WorkController).GetRequestAll,
                        "DELETE /api/worklog/{workid}": (*WorkController).DeleteRequest,
                },
        }

        for path, handler := range wc.controllers.GetPaths() </span><span class="cov8" title="1">{
                server.HandleFunc(path, handler(wc, ctx))
        }</span>

        <span class="cov8" title="1">wc.server = server
        return wc</span>
}

func (wc *WorkController) Start() error <span class="cov0" title="0">{
        log.Printf("Starting work controller")
        return nil
}</span>

func (wc *WorkController) Stop() error <span class="cov0" title="0">{
        log.Printf("Stopping work controller")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package events

import (
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "time"

        utils "github.com/papawattu/cleanlog-worklog/internal"
        "github.com/papawattu/cleanlog-worklog/internal/models"
        "github.com/papawattu/cleanlog-worklog/internal/repo"
)

const (
        WorkLogCreated = "WorkLogCreated"
        WorkLogDeleted = "WorkLogDeleted"
        EventUri       = "/event"
        EventVersion   = 1
)

type EventBroadcaster struct {
        repo         repo.Repository[*models.WorkLog, int]
        broadcastUri string
}

type Event struct {
        EventType    string    `json:"eventType"`
        EventTime    time.Time `json:"eventTime"`
        EventVersion uint32    `json:"eventVersion"`
        EventSHA     string    `json:"eventSHA"`
        EventData    string    `json:"eventData"`
}

func (eb *EventBroadcaster) postEvent(event Event) error <span class="cov0" title="0">{

        ev, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := utils.NewRetryableClient(10)

        r, err := http.NewRequest("POST", eb.broadcastUri, bytes.NewBuffer(ev))

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.Header.Add("Content-Type", "application/json")

        resp, err := client.Do(r)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return fmt.Errorf("Error: status code %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (eb *EventBroadcaster) Save(ctx context.Context, wl *models.WorkLog) error <span class="cov0" title="0">{

        wlj, err := json.Marshal(wl)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h := sha256.New()

        h.Write([]byte(wlj))

        // Broadcast event
        event := Event{
                EventType:    WorkLogCreated,
                EventTime:    time.Now(),
                EventVersion: EventVersion,
                EventSHA:     fmt.Sprintf("%x", h.Sum(nil)),
                EventData:    string(wlj),
        }

        err = eb.postEvent(event)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // err = eb.repo.SaveWorkLog(wl)

        // if err != nil {

        //         err := eb.DeleteWorkLog(*wl.WorkLogID)
        //         if err != nil {
        //                 log.Panicf("Error saving work log: %v published rollback event", err)
        //         }
        //         log.Printf("Error saving work log: %v published rollback event", err)
        //         return err
        // }

        <span class="cov0" title="0">return nil</span> //
}

func (eb *EventBroadcaster) Get(ctx context.Context, id int) (*models.WorkLog, error) <span class="cov0" title="0">{
        return eb.repo.Get(ctx, id)
}</span>

func (eb *EventBroadcaster) GetAll(ctx context.Context) ([]*models.WorkLog, error) <span class="cov0" title="0">{
        return eb.repo.GetAll(ctx)
}</span>

func (eb *EventBroadcaster) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{

        wl, err := eb.repo.Get(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wlj, err := json.Marshal(wl)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h := sha256.New()

        h.Write([]byte(wlj))

        // Broadcast event
        event := Event{
                EventType:    WorkLogDeleted,
                EventTime:    time.Now(),
                EventVersion: EventVersion,
                EventSHA:     fmt.Sprintf("%x", h.Sum(nil)),
                EventData:    string(wlj),
        }

        err = eb.postEvent(event)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span> // eb.repo.DeleteWorkLog(id)
}

func NewEventBroadcaster(ctx context.Context, repo repo.Repository[*models.WorkLog, int], broadcastUri string, streamUri, topic string) *EventBroadcaster <span class="cov0" title="0">{

        es := make(chan string)

        go EventStream(ctx, streamUri, es, topic)

        go func() </span><span class="cov0" title="0">{
                sha := make(map[string]string)

                for </span><span class="cov0" title="0">{
                        ev := &lt;-es
                        if ev == "" </span><span class="cov0" title="0">{
                                log.Printf("Received empty event %+v", es)
                                continue</span>
                        }
                        <span class="cov0" title="0">if ev == "Error connecting to event stream" </span><span class="cov0" title="0">{
                                log.Printf("Error connecting to event stream")
                        }</span>

                        <span class="cov0" title="0">log.Printf("Received event: %s", ev)

                        event := decodeEvent(ev)

                        if _, ok := sha[event.EventSHA]; ok </span><span class="cov0" title="0">{
                                log.Printf("Skipping event %s", event.EventSHA)
                                continue</span>
                        }

                        <span class="cov0" title="0">sha[event.EventSHA] = ev

                        switch event.EventType </span>{
                        case WorkLogCreated:<span class="cov0" title="0">
                                log.Printf("Received work log created event %v", event.EventData)
                                wl := decodeWorkLog(event.EventData)
                                err := repo.Save(ctx, wl)
                                log.Printf("Saved work log %v", wl)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error saving work log: %v", err)
                                }</span>
                        case WorkLogDeleted:<span class="cov0" title="0">
                                wl := decodeWorkLog(event.EventData)
                                err := repo.Delete(ctx, *wl.WorkLogID)

                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error deleting work log: %v", err)
                                }</span>
                        }
                }

        }()

        <span class="cov0" title="0">return &amp;EventBroadcaster{
                repo:         repo,
                broadcastUri: broadcastUri + "/event/" + topic,
        }</span>
}

func decodeWorkLog(data string) *models.WorkLog <span class="cov0" title="0">{
        var wl models.WorkLog
        err := json.Unmarshal([]byte(data), &amp;wl)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error decoding work log: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;wl</span>
}

func decodeEvent(ev string) Event <span class="cov0" title="0">{
        var event Event
        err := json.Unmarshal([]byte(ev), &amp;event)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error decoding event: %s : %v", ev, err)
        }</span>
        <span class="cov0" title="0">return event</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package events

import (
        "bufio"
        "context"
        "log"
        "net/http"
        "strings"

        utils "github.com/papawattu/cleanlog-worklog/internal"
)

func EventStream(ctx context.Context, baseUri string, es chan string, topic string) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                client := utils.NewRetryableClient(10)

                req, err := http.NewRequest("GET", baseUri+"/eventstream/"+topic, nil)

                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error creating request: %v", err)
                }</span>

                <span class="cov0" title="0">req.Header.Set("Accept", "text/event-stream")
                req.Header.Set("Cache-Control", "no-cache")

                resp, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error connecting to event stream: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        log.Fatalf("Error: status code %d", resp.StatusCode)
                        es &lt;- "Error connecting to event stream"
                }</span>

                <span class="cov0" title="0">log.Println("Connected to event stream")
                scanner := bufio.NewScanner(resp.Body)

                for running := true; running; </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Println("Timeout")
                                running = false
                                break</span>
                        case &lt;-req.Context().Done():<span class="cov0" title="0">
                                log.Println("Client connection closed")
                                running = false
                                break</span>
                        default:<span class="cov0" title="0">
                                scanner.Scan()
                                e := scanner.Text()
                                if e == "" </span><span class="cov0" title="0">{
                                        log.Println("Empty event")
                                        running = false
                                        break</span>
                                }

                                <span class="cov0" title="0">if !strings.HasPrefix(e, "data: ") </span><span class="cov0" title="0">{
                                        log.Fatalf("Error: unexpected event %s", e)
                                        running = false
                                        break</span>
                                }
                                <span class="cov0" title="0">es &lt;- strings.TrimLeft(e, "data: ")</span>
                        }
                }
        }

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import "time"

type Task struct {
        TaskID int
}
type WorkLog struct {
        WorkLogID          *int
        WorkLogDate        time.Time
        WorkLogTimeInSecs  int
        WorkLogDescription string
        Tasks              []Task
        UserID             int
        CreationDate       time.Time
        LastUpdateDate     time.Time
}
type Work interface {
        LogWork(WorkLog) error
}

func NewWorkLog(description string, date time.Time) (WorkLog, error) <span class="cov8" title="1">{

        wl := WorkLog{
                WorkLogID:          nil,
                WorkLogDate:        date,
                WorkLogDescription: description,
                CreationDate:       time.Now(),
                LastUpdateDate:     time.Now(),
                Tasks:              make([]Task, 0),
                UserID:             0,
        }
        return wl, nil
}</span>

func (wl *WorkLog) LogWork(t Task) error <span class="cov8" title="1">{
        wl.Tasks = append(wl.Tasks, t)
        return nil
}</span>

func (wl *WorkLog) EndWork() error <span class="cov8" title="1">{
        now := time.Now()
        worked := now.Sub(wl.WorkLogDate)
        wl.WorkLogTimeInSecs = int(worked.Seconds())
        wl.LastUpdateDate = now
        return nil
}</span>

func (wl *WorkLog) AddTask(t Task) error <span class="cov8" title="1">{
        wl.Tasks = append(wl.Tasks, t)
        return nil
}</span>

func (wl *WorkLog) RemoveTask(t Task) error <span class="cov8" title="1">{
        for i, task := range wl.Tasks </span><span class="cov8" title="1">{
                if task.TaskID == t.TaskID </span><span class="cov8" title="1">{
                        wl.Tasks = append(wl.Tasks[:i], wl.Tasks[i+1:]...)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (wl *WorkLog) ChangeDescription(description string) error <span class="cov8" title="1">{
        wl.WorkLogDescription = description
        return nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package repo

import (
        "context"
        "errors"
        "log"
        "strconv"
        "time"

        "github.com/papawattu/cleanlog-worklog/internal/models"
)

type InMemoryWorkLogRepository struct {
        WorkLogs map[int]*models.WorkLog
}

func (wri *InMemoryWorkLogRepository) Save(ctx context.Context, wl *models.WorkLog) error <span class="cov8" title="1">{
        if wl.WorkLogID == nil </span><span class="cov0" title="0">{
                return errors.New("work log ID is required")
        }</span>

        <span class="cov8" title="1">if _, ok := wri.WorkLogs[*wl.WorkLogID]; ok </span><span class="cov0" title="0">{
                return errors.New("work log already exists")
        }</span>

        <span class="cov8" title="1">wl.LastUpdateDate = time.Now()
        wri.WorkLogs[*wl.WorkLogID] = wl
        return nil</span>
}

func (wri *InMemoryWorkLogRepository) Get(ctx context.Context, id int) (*models.WorkLog, error) <span class="cov8" title="1">{
        wl, ok := wri.WorkLogs[id]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return wl, nil</span>
}

func (wri *InMemoryWorkLogRepository) GetAll(ctx context.Context) ([]*models.WorkLog, error) <span class="cov8" title="1">{
        userID := ctx.Value("userID")

        workLogs := []*models.WorkLog{}
        for _, wl := range wri.WorkLogs </span><span class="cov0" title="0">{
                if wl.UserID == userID </span><span class="cov0" title="0">{
                        workLogs = append(workLogs, wl)
                }</span>
        }
        <span class="cov8" title="1">return workLogs, nil</span>
}

func (wri *InMemoryWorkLogRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        if _, ok := wri.WorkLogs[id]; !ok </span><span class="cov0" title="0">{
                log.Printf("Work log with ID %d not found", id)
                return errors.New("work log not found " + strconv.Itoa(id))
        }</span>
        <span class="cov0" title="0">delete(wri.WorkLogs, id)
        return nil</span>
}
func NewWorkLogRepository() Repository[*models.WorkLog, int] <span class="cov8" title="1">{
        return &amp;InMemoryWorkLogRepository{
                WorkLogs: make(map[int]*models.WorkLog),
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "context"
        "errors"
        "log"
        "math/rand"
        "time"

        "github.com/papawattu/cleanlog-worklog/internal/models"
        "github.com/papawattu/cleanlog-worklog/internal/repo"
)

type WorkService interface {
        CreateWorkLog(ctx context.Context, description string, date time.Time) (int, error)

        DeleteWorkLog(ctx context.Context, id int) error

        GetWorkLog(ctx context.Context, id int) (*models.WorkLog, error)

        GetAllWorkLog(ctx context.Context, user int) ([]*models.WorkLog, error)

        UpdateWorkLog(ctx context.Context, id int, description string, date time.Time) error
}

type WorkServiceImp struct {
        repo repo.Repository[*models.WorkLog, int]
}

func nextId() int <span class="cov8" title="1">{
        return rand.Intn(1000)
}</span>

func (wsi *WorkServiceImp) CreateWorkLog(ctx context.Context, description string, date time.Time) (int, error) <span class="cov8" title="1">{

        wl, err := models.NewWorkLog(description, date)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error starting work: %v", err)
                return 0, err
        }</span>

        <span class="cov8" title="1">nextId := nextId()
        wl.WorkLogID = &amp;nextId

        err = wsi.repo.Save(ctx, &amp;wl)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error saving work log: %v", err)
                return 0, err
        }</span>
        <span class="cov8" title="1">return nextId, nil</span>
}

func (wsi *WorkServiceImp) LogWork(ctx context.Context, id int, t models.Task) error <span class="cov0" title="0">{

        wl, err := wsi.repo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error getting work log: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">err = wl.LogWork(t)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error logging work: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (wsi *WorkServiceImp) DeleteWorkLog(ctx context.Context, id int) error <span class="cov0" title="0">{

        wl, err := wsi.repo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error getting work log: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">if wl == nil </span><span class="cov0" title="0">{
                return errors.New("Work log not found")
        }</span>

        <span class="cov0" title="0">err = wl.EndWork()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error ending work")
                return err
        }</span>

        <span class="cov0" title="0">err = wsi.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error deleting work log: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (wsi *WorkServiceImp) GetWorkLog(ctx context.Context, id int) (*models.WorkLog, error) <span class="cov8" title="1">{

        wl, err := wsi.repo.Get(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error getting work log: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return wl, nil</span>
}
func (wsi *WorkServiceImp) GetAllWorkLog(ctx context.Context, user int) ([]*models.WorkLog, error) <span class="cov8" title="1">{

        wls, err := wsi.repo.GetAll(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error getting work log: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return wls, nil</span>
}

func (wsi *WorkServiceImp) UpdateWorkLog(ctx context.Context, id int, description string, date time.Time) error <span class="cov0" title="0">{

        wl, err := wsi.repo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error getting work log: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">wl.WorkLogDescription = description
        wl.WorkLogDate = date

        err = wsi.repo.Save(ctx, wl)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error updating work log: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
func NewWorkService(repo repo.Repository[*models.WorkLog, int]) WorkService <span class="cov8" title="1">{

        return &amp;WorkServiceImp{
                repo: repo,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package utils

import (
        "bytes"
        "io"
        "math"
        "net/http"
        "time"
)

func backoff(retries int) time.Duration <span class="cov0" title="0">{
        return time.Duration(math.Pow(2, float64(retries))) * time.Second
}</span>

func shouldRetry(err error, resp *http.Response) bool <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == http.StatusBadGateway ||
                resp.StatusCode == http.StatusServiceUnavailable ||
                resp.StatusCode == http.StatusGatewayTimeout </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func drainBody(resp *http.Response) <span class="cov0" title="0">{
        if resp == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if resp.Body != nil </span><span class="cov0" title="0">{
                io.Copy(io.Discard, resp.Body)
                resp.Body.Close()
        }</span>
}

type retryableTransport struct {
        retries   int
        transport http.RoundTripper
}

func (t *retryableTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        // Clone the request body
        var bodyBytes []byte
        if req.Body != nil </span><span class="cov0" title="0">{
                bodyBytes, _ = io.ReadAll(req.Body)
                req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
        }</span>
        // Send the request
        <span class="cov0" title="0">resp, err := t.transport.RoundTrip(req)
        // Retry logic
        retries := 0
        for shouldRetry(err, resp) &amp;&amp; retries &lt; t.retries </span><span class="cov0" title="0">{
                // Wait for the specified backoff period
                time.Sleep(backoff(retries))
                // We're going to retry, consume any response to reuse the connection.
                drainBody(resp)
                // Clone the request body again
                if req.Body != nil </span><span class="cov0" title="0">{
                        req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
                }</span>
                // Retry the request
                <span class="cov0" title="0">resp, err = t.transport.RoundTrip(req)
                retries++</span>
        }
        // Return the response
        <span class="cov0" title="0">return resp, err</span>
}

func NewRetryableClient(times int) *http.Client <span class="cov0" title="0">{
        transport := &amp;retryableTransport{
                retries: times,
                transport: &amp;http.Transport{
                        MaxIdleConns:      0,
                        IdleConnTimeout:   0,
                        DisableKeepAlives: false,
                },
        }

        return &amp;http.Client{
                Transport: transport,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
